\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename ginac.info
@settitle GiNaC, an open framework for symbolic computation within the C++ programming language
@setchapternewpage on
@afourpaper
@c For `info' only.
@paragraphindent 0
@c For TeX only.
@iftex
@c I hate putting "@noindent" in front of every paragraph.
@parindent=0pt
@end iftex
@c %**end of header

@include version.texi

@direntry
* ginac: (ginac).                   C++ library for symbolic computation.
@end direntry

@ifinfo
This is a tutorial that documents GiNaC @value{VERSION}, an open
framework for symbolic computation within the C++ programming language.

Copyright (C) 1999-2000 Johannes Gutenberg University Mainz, Germany

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
@end ifinfo

@finalout
@c finalout prevents ugly black rectangles on overfull hbox lines
@titlepage
@title GiNaC @value{VERSION}
@subtitle An open framework for symbolic computation within the C++ programming language
@subtitle @value{UPDATED}
@author The GiNaC Group:
@author Christian Bauer, Alexander Frink, Richard Kreckel

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1999-2000 Johannes Gutenberg University Mainz, Germany
@sp 2
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
@end titlepage

@page
@contents

@page


@node Top, Introduction, (dir), (dir)
@c    node-name, next, previous, up
@top GiNaC

This is a tutorial that documents GiNaC @value{VERSION}, an open
framework for symbolic computation within the C++ programming language.

@menu
* Introduction::                 GiNaC's purpose.
* A Tour of GiNaC::              A quick tour of the library.
* Installation::                 How to install the package.
* Basic Concepts::               Description of fundamental classes.
* Methods and Functions::        Algorithms for symbolic manipulations.
* Extending GiNaC::              How to extend the library.
* A Comparison With Other CAS::  Compares GiNaC to traditional CAS.
* Internal Structures::          Description of some internal structures.
* Package Tools::                Configuring packages to work with GiNaC.
* Bibliography::
* Concept Index::
@end menu


@node Introduction, A Tour of GiNaC, Top, Top
@c    node-name, next, previous, up
@chapter Introduction
@cindex history of GiNaC

The motivation behind GiNaC derives from the observation that most
present day computer algebra systems (CAS) are linguistically and
semantically impoverished.  Although they are quite powerful tools for
learning math and solving particular problems they lack modern
linguistical structures that allow for the creation of large-scale
projects.  GiNaC is an attempt to overcome this situation by extending a
well established and standardized computer language (C++) by some
fundamental symbolic capabilities, thus allowing for integrated systems
that embed symbolic manipulations together with more established areas
of computer science (like computation-intense numeric applications,
graphical interfaces, etc.) under one roof.

The particular problem that led to the writing of the GiNaC framework is
still a very active field of research, namely the calculation of higher
order corrections to elementary particle interactions.  There,
theoretical physicists are interested in matching present day theories
against experiments taking place at particle accelerators.  The
computations involved are so complex they call for a combined symbolical
and numerical approach.  This turned out to be quite difficult to
accomplish with the present day CAS we have worked with so far and so we
tried to fill the gap by writing GiNaC.  But of course its applications
are in no way restricted to theoretical physics.

This tutorial is intended for the novice user who is new to GiNaC but
already has some background in C++ programming.  However, since a
hand-made documentation like this one is difficult to keep in sync with
the development, the actual documentation is inside the sources in the
form of comments.  That documentation may be parsed by one of the many
Javadoc-like documentation systems.  If you fail at generating it you
may access it from @uref{http://www.ginac.de/reference/, the GiNaC home
page}.  It is an invaluable resource not only for the advanced user who
wishes to extend the system (or chase bugs) but for everybody who wants
to comprehend the inner workings of GiNaC.  This little tutorial on the
other hand only covers the basic things that are unlikely to change in
the near future.

@section License
The GiNaC framework for symbolic computation within the C++ programming
language is Copyright @copyright{} 1999-2000 Johannes Gutenberg
University Mainz, Germany.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
MA 02111-1307, USA.


@node A Tour of GiNaC, How to use it from within C++, Introduction, Top
@c    node-name, next, previous, up
@chapter A Tour of GiNaC

This quick tour of GiNaC wants to arise your interest in the
subsequent chapters by showing off a bit.  Please excuse us if it
leaves many open questions.

@menu
* How to use it from within C++::  Two simple examples.
* What it can do for you::         A Tour of GiNaC's features.
@end menu


@node How to use it from within C++, What it can do for you, A Tour of GiNaC, A Tour of GiNaC
@c    node-name, next, previous, up
@section How to use it from within C++

The GiNaC open framework for symbolic computation within the C++ programming
language does not try to define a language of its own as conventional
CAS do.  Instead, it extends the capabilities of C++ by symbolic
manipulations.  Here is how to generate and print a simple (and rather
pointless) bivariate polynomial with some large coefficients:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y");
    ex poly;

    for (int i=0; i<3; ++i)
        poly += factorial(i+16)*pow(x,i)*pow(y,2-i);

    cout << poly << endl;
    return 0;
@}
@end example

Assuming the file is called @file{hello.cc}, on our system we can compile
and run it like this:

@example
$ c++ hello.cc -o hello -lcln -lginac
$ ./hello
355687428096000*x*y+20922789888000*y^2+6402373705728000*x^2
@end example

(@xref{Package Tools}, for tools that help you when creating a software
package that uses GiNaC.)

@cindex Hermite polynomial
Next, there is a more meaningful C++ program that calls a function which
generates Hermite polynomials in a specified free variable.

@example
#include <ginac/ginac.h>
using namespace GiNaC;

ex HermitePoly(const symbol & x, int n)
@{
    ex HKer=exp(-pow(x, 2));
    // uses the identity H_n(x) == (-1)^n exp(x^2) (d/dx)^n exp(-x^2)
    return normal(pow(-1, n) * diff(HKer, x, n) / HKer);
@}

int main()
@{
    symbol z("z");

    for (int i=0; i<6; ++i)
        cout << "H_" << i << "(z) == " << HermitePoly(z,i) << endl;

    return 0;
@}
@end example

When run, this will type out

@example
H_0(z) == 1
H_1(z) == 2*z
H_2(z) == 4*z^2-2
H_3(z) == -12*z+8*z^3
H_4(z) == -48*z^2+16*z^4+12
H_5(z) == 120*z-160*z^3+32*z^5
@end example

This method of generating the coefficients is of course far from optimal
for production purposes.

In order to show some more examples of what GiNaC can do we will now use
the @command{ginsh}, a simple GiNaC interactive shell that provides a
convenient window into GiNaC's capabilities.


@node What it can do for you, Installation, How to use it from within C++, A Tour of GiNaC
@c    node-name, next, previous, up
@section What it can do for you

@cindex @command{ginsh}
After invoking @command{ginsh} one can test and experiment with GiNaC's
features much like in other Computer Algebra Systems except that it does
not provide programming constructs like loops or conditionals.  For a
concise description of the @command{ginsh} syntax we refer to its
accompanied man page. Suffice to say that assignments and comparisons in
@command{ginsh} are written as they are in C, i.e. @code{=} assigns and
@code{==} compares.

It can manipulate arbitrary precision integers in a very fast way.
Rational numbers are automatically converted to fractions of coprime
integers:

@example
> x=3^150;
369988485035126972924700782451696644186473100389722973815184405301748249
> y=3^149;
123329495011708990974900260817232214728824366796574324605061468433916083
> x/y;
3
> y/x;
1/3
@end example

Exact numbers are always retained as exact numbers and only evaluated as
floating point numbers if requested.  For instance, with numeric
radicals is dealt pretty much as with symbols.  Products of sums of them
can be expanded:

@example
> expand((1+a^(1/5)-a^(2/5))^3);
1+3*a+3*a^(1/5)-5*a^(3/5)-a^(6/5)
> expand((1+3^(1/5)-3^(2/5))^3);
10-5*3^(3/5)
> evalf((1+3^(1/5)-3^(2/5))^3);
0.33408977534118624228
@end example

The function @code{evalf} that was used above converts any number in
GiNaC's expressions into floating point numbers.  This can be done to
arbitrary predefined accuracy:

@example
> evalf(1/7);
0.14285714285714285714
> Digits=150;
150
> evalf(1/7);
0.1428571428571428571428571428571428571428571428571428571428571428571428
5714285714285714285714285714285714285
@end example

Exact numbers other than rationals that can be manipulated in GiNaC
include predefined constants like Archimedes' @code{Pi}.  They can both
be used in symbolic manipulations (as an exact number) as well as in
numeric expressions (as an inexact number):

@example
> a=Pi^2+x;
x+Pi^2
> evalf(a);
9.869604401089358619+x
> x=2;
2
> evalf(a);
11.869604401089358619
@end example

Built-in functions evaluate immediately to exact numbers if
this is possible.  Conversions that can be safely performed are done
immediately; conversions that are not generally valid are not done:

@example
> cos(42*Pi);
1
> cos(acos(x));
x
> acos(cos(x));
acos(cos(x))
@end example

(Note that converting the last input to @code{x} would allow one to
conclude that @code{42*Pi} is equal to @code{0}.)

Linear equation systems can be solved along with basic linear
algebra manipulations over symbolic expressions.  In C++ GiNaC offers
a matrix class for this purpose but we can see what it can do using
@command{ginsh}'s notation of double brackets to type them in:

@example
> lsolve(a+x*y==z,x);
y^(-1)*(z-a);
> lsolve([3*x+5*y == 7, -2*x+10*y == -5], [x, y]);
[x==19/8,y==-1/40]
> M = [[ [[1, 3]], [[-3, 2]] ]];
[[ [[1,3]], [[-3,2]] ]]
> determinant(M);
11
> charpoly(M,lambda);
lambda^2-3*lambda+11
@end example

Multivariate polynomials and rational functions may be expanded,
collected and normalized (i.e. converted to a ratio of two coprime 
polynomials):

@example
> a = x^4 + 2*x^2*y^2 + 4*x^3*y + 12*x*y^3 - 3*y^4;
-3*y^4+x^4+12*x*y^3+2*x^2*y^2+4*x^3*y
> b = x^2 + 4*x*y - y^2;
-y^2+x^2+4*x*y
> expand(a*b);
3*y^6+x^6-24*x*y^5+43*x^2*y^4+16*x^3*y^3+17*x^4*y^2+8*x^5*y
> collect(a*b,x);
3*y^6+48*x*y^4+2*x^2*y^2+x^4*(-y^2+x^2+4*x*y)+4*x^3*y*(-y^2+x^2+4*x*y)
> normal(a/b);
3*y^2+x^2
@end example

You can differentiate functions and expand them as Taylor or Laurent
series in a very natural syntax (the second argument of @code{series} is
a relation defining the evaluation point, the third specifies the
order):

@cindex Zeta function
@example
> diff(tan(x),x);
tan(x)^2+1
> series(sin(x),x==0,4);
x-1/6*x^3+Order(x^4)
> series(1/tan(x),x==0,4);
x^(-1)-1/3*x+Order(x^2)
> series(tgamma(x),x==0,3);
x^(-1)-Euler+(1/12*Pi^2+1/2*Euler^2)*x+
(-1/3*zeta(3)-1/12*Pi^2*Euler-1/6*Euler^3)*x^2+Order(x^3)
> evalf(");
x^(-1)-0.5772156649015328606+(0.9890559953279725555)*x
-(0.90747907608088628905)*x^2+Order(x^3)
> series(tgamma(2*sin(x)-2),x==Pi/2,6);
-(x-1/2*Pi)^(-2)+(-1/12*Pi^2-1/2*Euler^2-1/240)*(x-1/2*Pi)^2
-Euler-1/12+Order((x-1/2*Pi)^3)
@end example

Here we have made use of the @command{ginsh}-command @code{"} to pop the
previously evaluated element from @command{ginsh}'s internal stack.

If you ever wanted to convert units in C or C++ and found this is
cumbersome, here is the solution.  Symbolic types can always be used as
tags for different types of objects.  Converting from wrong units to the
metric system is now easy:

@example
> in=.0254*m;
0.0254*m
> lb=.45359237*kg;
0.45359237*kg
> 200*lb/in^2;
140613.91592783185568*kg*m^(-2)
@end example


@node Installation, Prerequisites, What it can do for you, Top
@c    node-name, next, previous, up
@chapter Installation

@cindex CLN
GiNaC's installation follows the spirit of most GNU software. It is
easily installed on your system by three steps: configuration, build,
installation.

@menu
* Prerequisites::                Packages upon which GiNaC depends.
* Configuration::                How to configure GiNaC.
* Building GiNaC::               How to compile GiNaC.
* Installing GiNaC::             How to install GiNaC on your system.
@end menu


@node Prerequisites, Configuration, Installation, Installation
@c    node-name, next, previous, up
@section Prerequisites

In order to install GiNaC on your system, some prerequisites need to be
met.  First of all, you need to have a C++-compiler adhering to the
ANSI-standard @cite{ISO/IEC 14882:1998(E)}.  We used @acronym{GCC} for
development so if you have a different compiler you are on your own.
For the configuration to succeed you need a Posix compliant shell
installed in @file{/bin/sh}, GNU @command{bash} is fine.  Perl is needed
by the built process as well, since some of the source files are
automatically generated by Perl scripts.  Last but not least, Bruno
Haible's library @acronym{CLN} is extensively used and needs to be
installed on your system.  Please get it either from
@uref{ftp://ftp.santafe.edu/pub/gnu/}, from
@uref{ftp://ftpthep.physik.uni-mainz.de/pub/gnu/, GiNaC's FTP site} or
from @uref{ftp://ftp.ilog.fr/pub/Users/haible/gnu/, Bruno Haible's FTP
site} (it is covered by GPL) and install it prior to trying to install
GiNaC.  The configure script checks if it can find it and if it cannot
it will refuse to continue.


@node Configuration, Building GiNaC, Prerequisites, Installation
@c    node-name, next, previous, up
@section Configuration
@cindex configuration
@cindex Autoconf

To configure GiNaC means to prepare the source distribution for
building.  It is done via a shell script called @command{configure} that
is shipped with the sources and was originally generated by GNU
Autoconf.  Since a configure script generated by GNU Autoconf never
prompts, all customization must be done either via command line
parameters or environment variables.  It accepts a list of parameters,
the complete set of which can be listed by calling it with the
@option{--help} option.  The most important ones will be shortly
described in what follows:

@itemize @bullet

@item
@option{--disable-shared}: When given, this option switches off the
build of a shared library, i.e. a @file{.so} file.  This may be convenient
when developing because it considerably speeds up compilation.

@item
@option{--prefix=@var{PREFIX}}: The directory where the compiled library
and headers are installed. It defaults to @file{/usr/local} which means
that the library is installed in the directory @file{/usr/local/lib},
the header files in @file{/usr/local/include/ginac} and the documentation
(like this one) into @file{/usr/local/share/doc/GiNaC}.

@item
@option{--libdir=@var{LIBDIR}}: Use this option in case you want to have
the library installed in some other directory than
@file{@var{PREFIX}/lib/}.

@item
@option{--includedir=@var{INCLUDEDIR}}: Use this option in case you want
to have the header files installed in some other directory than
@file{@var{PREFIX}/include/ginac/}. For instance, if you specify
@option{--includedir=/usr/include} you will end up with the header files
sitting in the directory @file{/usr/include/ginac/}. Note that the
subdirectory @file{ginac} is enforced by this process in order to
keep the header files separated from others.  This avoids some
clashes and allows for an easier deinstallation of GiNaC. This ought
to be considered A Good Thing (tm).

@item
@option{--datadir=@var{DATADIR}}: This option may be given in case you
want to have the documentation installed in some other directory than
@file{@var{PREFIX}/share/doc/GiNaC/}.

@end itemize

In addition, you may specify some environment variables.
@env{CXX} holds the path and the name of the C++ compiler
in case you want to override the default in your path.  (The
@command{configure} script searches your path for @command{c++},
@command{g++}, @command{gcc}, @command{CC}, @command{cxx}
and @command{cc++} in that order.)  It may be very useful to
define some compiler flags with the @env{CXXFLAGS} environment
variable, like optimization, debugging information and warning
levels.  If omitted, it defaults to @option{-g -O2}.

The whole process is illustrated in the following two
examples. (Substitute @command{setenv @var{VARIABLE} @var{value}} for
@command{export @var{VARIABLE}=@var{value}} if the Berkeley C shell is
your login shell.)

Here is a simple configuration for a site-wide GiNaC library assuming
everything is in default paths:

@example
$ export CXXFLAGS="-Wall -O2"
$ ./configure
@end example

And here is a configuration for a private static GiNaC library with
several components sitting in custom places (site-wide @acronym{GCC} and
private @acronym{CLN}).  The compiler is pursuaded to be picky and full
assertions and debugging information are switched on:

@example
$ export CXX=/usr/local/gnu/bin/c++
$ export CPPFLAGS="$(CPPFLAGS) -I$(HOME)/include"
$ export CXXFLAGS="$(CXXFLAGS) -DDO_GINAC_ASSERT -ggdb -Wall -ansi -pedantic"
$ export LDFLAGS="$(LDFLAGS) -L$(HOME)/lib"
$ ./configure --disable-shared --prefix=$(HOME)
@end example


@node Building GiNaC, Installing GiNaC, Configuration, Installation
@c    node-name, next, previous, up
@section Building GiNaC
@cindex building GiNaC

After proper configuration you should just build the whole
library by typing
@example
$ make
@end example
at the command prompt and go for a cup of coffee.  The exact time it
takes to compile GiNaC depends not only on the speed of your machines
but also on other parameters, for instance what value for @env{CXXFLAGS}
you entered.  Optimization may be very time-consuming.

Just to make sure GiNaC works properly you may run a collection of
regression tests by typing

@example
$ make check
@end example

This will compile some sample programs, run them and check the output
for correctness.  The regression tests fall in three categories.  First,
the so called @emph{exams} are performed, simple tests where some
predefined input is evaluated (like a pupils' exam).  Second, the
@emph{checks} test the coherence of results among each other with
possible random input.  Third, some @emph{timings} are performed, which
benchmark some predefined problems with different sizes and display the
CPU time used in seconds.  Each individual test should return a message
@samp{passed}.  This is mostly intended to be a QA-check if something
was broken during development, not a sanity check of your system.  Some
of the tests in sections @emph{checks} and @emph{timings} may require
insane amounts of memory and CPU time.  Feel free to kill them if your
machine catches fire.  Another quite important intent is to allow people
to fiddle around with optimization.

Generally, the top-level Makefile runs recursively to the
subdirectories.  It is therfore safe to go into any subdirectory
(@code{doc/}, @code{ginsh/}, ...) and simply type @code{make}
@var{target} there in case something went wrong.


@node Installing GiNaC, Basic Concepts, Building GiNaC, Installation
@c    node-name, next, previous, up
@section Installing GiNaC
@cindex installation

To install GiNaC on your system, simply type

@example
$ make install
@end example

As described in the section about configuration the files will be
installed in the following directories (the directories will be created
if they don't already exist):

@itemize @bullet

@item
@file{libginac.a} will go into @file{@var{PREFIX}/lib/} (or
@file{@var{LIBDIR}}) which defaults to @file{/usr/local/lib/}.
So will @file{libginac.so} unless the configure script was
given the option @option{--disable-shared}.  The proper symlinks
will be established as well.

@item
All the header files will be installed into @file{@var{PREFIX}/include/ginac/}
(or @file{@var{INCLUDEDIR}/ginac/}, if specified).

@item
All documentation (HTML and Postscript) will be stuffed into
@file{@var{PREFIX}/share/doc/GiNaC/} (or
@file{@var{DATADIR}/doc/GiNaC/}, if @var{DATADIR} was specified).

@end itemize

For the sake of completeness we will list some other useful make
targets: @command{make clean} deletes all files generated by
@command{make}, i.e. all the object files.  In addition @command{make
distclean} removes all files generated by the configuration and
@command{make maintainer-clean} goes one step further and deletes files
that may require special tools to rebuild (like the @command{libtool}
for instance).  Finally @command{make uninstall} removes the installed
library, header files and documentation@footnote{Uninstallation does not
work after you have called @command{make distclean} since the
@file{Makefile} is itself generated by the configuration from
@file{Makefile.in} and hence deleted by @command{make distclean}.  There
are two obvious ways out of this dilemma.  First, you can run the
configuration again with the same @var{PREFIX} thus creating a
@file{Makefile} with a working @samp{uninstall} target.  Second, you can
do it by hand since you now know where all the files went during
installation.}.


@node Basic Concepts, Expressions, Installing GiNaC, Top
@c    node-name, next, previous, up
@chapter Basic Concepts

This chapter will describe the different fundamental objects that can be
handled by GiNaC.  But before doing so, it is worthwhile introducing you
to the more commonly used class of expressions, representing a flexible
meta-class for storing all mathematical objects.

@menu
* Expressions::                  The fundamental GiNaC class.
* The Class Hierarchy::          Overview of GiNaC's classes.
* Symbols::                      Symbolic objects.
* Numbers::                      Numerical objects.
* Constants::                    Pre-defined constants.
* Fundamental containers::       The power, add and mul classes.
* Lists::                        Lists of expressions.
* Mathematical functions::       Mathematical functions.
* Relations::                    Equality, Inequality and all that.
@end menu


@node Expressions, The Class Hierarchy, Basic Concepts, Basic Concepts
@c    node-name, next, previous, up
@section Expressions
@cindex expression (class @code{ex})
@cindex @code{has()}

The most common class of objects a user deals with is the expression
@code{ex}, representing a mathematical object like a variable, number,
function, sum, product, etc...  Expressions may be put together to form
new expressions, passed as arguments to functions, and so on.  Here is a
little collection of valid expressions:

@example
ex MyEx1 = 5;                       // simple number
ex MyEx2 = x + 2*y;                 // polynomial in x and y
ex MyEx3 = (x + 1)/(x - 1);         // rational expression
ex MyEx4 = sin(x + 2*y) + 3*z + 41; // containing a function
ex MyEx5 = MyEx4 + 1;               // similar to above
@end example

Expressions are handles to other more fundamental objects, that many
times contain other expressions thus creating a tree of expressions
(@xref{Internal Structures}, for particular examples).  Most methods on
@code{ex} therefore run top-down through such an expression tree.  For
example, the method @code{has()} scans recursively for occurrences of
something inside an expression.  Thus, if you have declared @code{MyEx4}
as in the example above @code{MyEx4.has(y)} will find @code{y} inside
the argument of @code{sin} and hence return @code{true}.

The next sections will outline the general picture of GiNaC's class
hierarchy and describe the classes of objects that are handled by
@code{ex}.


@node The Class Hierarchy, Symbols, Expressions, Basic Concepts
@c    node-name, next, previous, up
@section The Class Hierarchy

GiNaC's class hierarchy consists of several classes representing
mathematical objects, all of which (except for @code{ex} and some
helpers) are internally derived from one abstract base class called
@code{basic}.  You do not have to deal with objects of class
@code{basic}, instead you'll be dealing with symbols, numbers,
containers of expressions and so on.  You'll soon learn in this chapter
how many of the functions on symbols are really classes.  This is
because simple symbolic arithmetic is not supported by languages like
C++ so in a certain way GiNaC has to implement its own arithmetic.

@cindex container
@cindex atom
To get an idea about what kinds of symbolic composits may be built we
have a look at the most important classes in the class hierarchy.  The
oval classes are atomic ones and the squared classes are containers.
The dashed line symbolizes a `points to' or `handles' relationship while
the solid lines stand for `inherits from' relationship in the class
hierarchy:

@image{classhierarchy}

Some of the classes shown here (the ones sitting in white boxes) are
abstract base classes that are of no interest at all for the user.  They
are used internally in order to avoid code duplication if two or more
classes derived from them share certain features.  An example would be
@code{expairseq}, which is a container for a sequence of pairs each
consisting of one expression and a number (@code{numeric}).  What
@emph{is} visible to the user are the derived classes @code{add} and
@code{mul}, representing sums of terms and products, respectively.
@xref{Internal Structures}, where these two classes are described in
more detail.

At this point, we only summarize what kind of mathematical objects are
stored in the different classes in above diagram in order to give you a
overview:

@cartouche
@multitable @columnfractions .22 .78
@item @code{symbol} @tab Algebraic symbols @math{a}, @math{x}, @math{y}@dots{}
@item @code{constant} @tab Constants like 
@tex
$\pi$
@end tex
@ifnottex
@math{Pi}
@end ifnottex
@item @code{numeric} @tab All kinds of numbers, @math{42}, @math{7/3*I}, @math{3.14159}@dots{}
@item @code{add} @tab Sums like @math{x+y} or @math{a+(2*b)+3}
@item @code{mul} @tab Products like @math{x*y} or @math{a*(x+y+z)*b*2}
@item @code{power} @tab Exponentials such as @math{x^2}, @math{a^b}, 
@tex
$\sqrt{2}$
@end tex
@ifnottex
@code{sqrt(}@math{2}@code{)}
@end ifnottex
@dots{}
@item @code{pseries} @tab Power Series, e.g. @math{x+1/6*x^3+1/120*x^5+O(x^7)}
@item @code{function} @tab A symbolic function like @math{sin(2*x)}
@item @code{lst} @tab Lists of expressions [@math{x}, @math{2*y}, @math{3+z}]
@item @code{matrix} @tab @math{n}x@math{m} matrices of expressions
@item @code{relational} @tab A relation like the identity @math{x}@code{==}@math{y}
@item @code{color} @tab Element of the @math{SU(3)} Lie-algebra
@item @code{isospin} @tab Element of the @math{SU(2)} Lie-algebra
@item @code{idx} @tab Index of a tensor object
@item @code{coloridx} @tab Index of a @math{SU(3)} tensor
@end multitable
@end cartouche

@node Symbols, Numbers, The Class Hierarchy, Basic Concepts
@c    node-name, next, previous, up
@section Symbols
@cindex @code{symbol} (class)
@cindex hierarchy of classes

@cindex atom
Symbols are for symbolic manipulation what atoms are for chemistry.  You
can declare objects of class @code{symbol} as any other object simply by
saying @code{symbol x,y;}.  There is, however, a catch in here having to
do with the fact that C++ is a compiled language.  The information about
the symbol's name is thrown away by the compiler but at a later stage
you may want to print expressions holding your symbols.  In order to
avoid confusion GiNaC's symbols are able to know their own name.  This
is accomplished by declaring its name for output at construction time in
the fashion @code{symbol x("x");}.  If you declare a symbol using the
default constructor (i.e. without string argument) the system will deal
out a unique name.  That name may not be suitable for printing but for
internal routines when no output is desired it is often enough.  We'll
come across examples of such symbols later in this tutorial.

This implies that the strings passed to symbols at construction time may
not be used for comparing two of them.  It is perfectly legitimate to
write @code{symbol x("x"),y("x");} but it is likely to lead into
trouble.  Here, @code{x} and @code{y} are different symbols and
statements like @code{x-y} will not be simplified to zero although the
output @code{x-x} looks funny.  Such output may also occur when there
are two different symbols in two scopes, for instance when you call a
function that declares a symbol with a name already existent in a symbol
in the calling function.  Again, comparing them (using @code{operator==}
for instance) will always reveal their difference.  Watch out, please.

@cindex @code{subs()}
Although symbols can be assigned expressions for internal reasons, you
should not do it (and we are not going to tell you how it is done).  If
you want to replace a symbol with something else in an expression, you
can use the expression's @code{.subs()} method (@xref{Substituting Symbols},
for more information).


@node Numbers, Constants, Symbols, Basic Concepts
@c    node-name, next, previous, up
@section Numbers
@cindex @code{numeric} (class)

@cindex GMP
@cindex CLN
@cindex rational
@cindex fraction
For storing numerical things, GiNaC uses Bruno Haible's library
@acronym{CLN}.  The classes therein serve as foundation classes for
GiNaC.  @acronym{CLN} stands for Class Library for Numbers or
alternatively for Common Lisp Numbers.  In order to find out more about
@acronym{CLN}'s internals the reader is refered to the documentation of
that library.  @inforef{Introduction, , cln}, for more
information. Suffice to say that it is by itself build on top of another
library, the GNU Multiple Precision library @acronym{GMP}, which is an
extremely fast library for arbitrary long integers and rationals as well
as arbitrary precision floating point numbers.  It is very commonly used
by several popular cryptographic applications.  @acronym{CLN} extends
@acronym{GMP} by several useful things: First, it introduces the complex
number field over either reals (i.e. floating point numbers with
arbitrary precision) or rationals.  Second, it automatically converts
rationals to integers if the denominator is unity and complex numbers to
real numbers if the imaginary part vanishes and also correctly treats
algebraic functions.  Third it provides good implementations of
state-of-the-art algorithms for all trigonometric and hyperbolic
functions as well as for calculation of some useful constants.

The user can construct an object of class @code{numeric} in several
ways.  The following example shows the four most important constructors.
It uses construction from C-integer, construction of fractions from two
integers, construction from C-float and construction from a string:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    numeric two(2);                       // exact integer 2
    numeric r(2,3);                       // exact fraction 2/3
    numeric e(2.71828);                   // floating point number
    numeric p("3.1415926535897932385");   // floating point number
    // Trott's constant in scientific notation:
    numeric trott("1.0841015122311136151E-2");
    
    cout << two*p << endl;  // floating point 6.283...
@}
@end example

Note that all those constructors are @emph{explicit} which means you are
not allowed to write @code{numeric two=2;}.  This is because the basic
objects to be handled by GiNaC are the expressions @code{ex} and we want
to keep things simple and wish objects like @code{pow(x,2)} to be
handled the same way as @code{pow(x,a)}, which means that we need to
allow a general @code{ex} as base and exponent.  Therefore there is an
implicit constructor from C-integers directly to expressions handling
numerics at work in most of our examples.  This design really becomes
convenient when one declares own functions having more than one
parameter but it forbids using implicit constructors because that would
lead to compile-time ambiguities.

It may be tempting to construct numbers writing @code{numeric r(3/2)}.
This would, however, call C's built-in operator @code{/} for integers
first and result in a numeric holding a plain integer 1.  @strong{Never
use the operator @code{/} on integers} unless you know exactly what you
are doing!  Use the constructor from two integers instead, as shown in
the example above.  Writing @code{numeric(1)/2} may look funny but works
also.

@cindex @code{Digits}
@cindex accuracy
We have seen now the distinction between exact numbers and floating
point numbers.  Clearly, the user should never have to worry about
dynamically created exact numbers, since their `exactness' always
determines how they ought to be handled, i.e. how `long' they are.  The
situation is different for floating point numbers.  Their accuracy is
controlled by one @emph{global} variable, called @code{Digits}.  (For
those readers who know about Maple: it behaves very much like Maple's
@code{Digits}).  All objects of class numeric that are constructed from
then on will be stored with a precision matching that number of decimal
digits:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

void foo()
@{
    numeric three(3.0), one(1.0);
    numeric x = one/three;

    cout << "in " << Digits << " digits:" << endl;
    cout << x << endl;
    cout << Pi.evalf() << endl;
@}

int main()
@{
    foo();
    Digits = 60;
    foo();
    return 0;
@}
@end example

The above example prints the following output to screen:

@example
in 17 digits:
0.333333333333333333
3.14159265358979324
in 60 digits:
0.333333333333333333333333333333333333333333333333333333333333333333
3.14159265358979323846264338327950288419716939937510582097494459231
@end example

It should be clear that objects of class @code{numeric} should be used
for constructing numbers or for doing arithmetic with them.  The objects
one deals with most of the time are the polymorphic expressions @code{ex}.

@subsection Tests on numbers

Once you have declared some numbers, assigned them to expressions and
done some arithmetic with them it is frequently desired to retrieve some
kind of information from them like asking whether that number is
integer, rational, real or complex.  For those cases GiNaC provides
several useful methods.  (Internally, they fall back to invocations of
certain CLN functions.)

As an example, let's construct some rational number, multiply it with
some multiple of its denominator and test what comes out:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

// some very important constants:
const numeric twentyone(21);
const numeric ten(10);
const numeric five(5);

int main()
@{
    numeric answer = twentyone;

    answer /= five;
    cout << answer.is_integer() << endl;  // false, it's 21/5
    answer *= ten;
    cout << answer.is_integer() << endl;  // true, it's 42 now!
@}
@end example

Note that the variable @code{answer} is constructed here as an integer
by @code{numeric}'s copy constructor but in an intermediate step it
holds a rational number represented as integer numerator and integer
denominator.  When multiplied by 10, the denominator becomes unity and
the result is automatically converted to a pure integer again.
Internally, the underlying @acronym{CLN} is responsible for this
behaviour and we refer the reader to @acronym{CLN}'s documentation.
Suffice to say that the same behaviour applies to complex numbers as
well as return values of certain functions.  Complex numbers are
automatically converted to real numbers if the imaginary part becomes
zero.  The full set of tests that can be applied is listed in the
following table.

@cartouche
@multitable @columnfractions .30 .70
@item @strong{Method} @tab @strong{Returns true if the object is@dots{}}
@item @code{.is_zero()}
@tab @dots{}equal to zero
@item @code{.is_positive()}
@tab @dots{}not complex and greater than 0
@item @code{.is_integer()}
@tab @dots{}a (non-complex) integer
@item @code{.is_pos_integer()}
@tab @dots{}an integer and greater than 0
@item @code{.is_nonneg_integer()}
@tab @dots{}an integer and greater equal 0
@item @code{.is_even()}
@tab @dots{}an even integer
@item @code{.is_odd()}
@tab @dots{}an odd integer
@item @code{.is_prime()}
@tab @dots{}a prime integer (probabilistic primality test)
@item @code{.is_rational()}
@tab @dots{}an exact rational number (integers are rational, too)
@item @code{.is_real()}
@tab @dots{}a real integer, rational or float (i.e. is not complex)
@item @code{.is_cinteger()}
@tab @dots{}a (complex) integer (such as @math{2-3*I})
@item @code{.is_crational()}
@tab @dots{}an exact (complex) rational number (such as @math{2/3+7/2*I})
@end multitable
@end cartouche


@node Constants, Fundamental containers, Numbers, Basic Concepts
@c    node-name, next, previous, up
@section Constants
@cindex @code{constant} (class)

@cindex @code{Pi}
@cindex @code{Catalan}
@cindex @code{Euler}
@cindex @code{evalf()}
Constants behave pretty much like symbols except that they return some
specific number when the method @code{.evalf()} is called.

The predefined known constants are:

@cartouche
@multitable @columnfractions .14 .30 .56
@item @strong{Name} @tab @strong{Common Name} @tab @strong{Numerical Value (to 35 digits)}
@item @code{Pi}
@tab Archimedes' constant
@tab 3.14159265358979323846264338327950288
@item @code{Catalan}
@tab Catalan's constant
@tab 0.91596559417721901505460351493238411
@item @code{Euler}
@tab Euler's (or Euler-Mascheroni) constant
@tab 0.57721566490153286060651209008240243
@end multitable
@end cartouche


@node Fundamental containers, Lists, Constants, Basic Concepts
@c    node-name, next, previous, up
@section Fundamental containers: the @code{power}, @code{add} and @code{mul} classes
@cindex polynomial
@cindex @code{add}
@cindex @code{mul}
@cindex @code{power}

Simple polynomial expressions are written down in GiNaC pretty much like
in other CAS or like expressions involving numerical variables in C.
The necessary operators @code{+}, @code{-}, @code{*} and @code{/} have
been overloaded to achieve this goal.  When you run the following
program, the constructor for an object of type @code{mul} is
automatically called to hold the product of @code{a} and @code{b} and
then the constructor for an object of type @code{add} is called to hold
the sum of that @code{mul} object and the number one:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol a("a"), b("b");
    ex MyTerm = 1+a*b;
    // ...
@}
@end example

@cindex @code{pow()}
For exponentiation, you have already seen the somewhat clumsy (though C-ish)
statement @code{pow(x,2);} to represent @code{x} squared.  This direct
construction is necessary since we cannot safely overload the constructor
@code{^} in C++ to construct a @code{power} object.  If we did, it would
have several counterintuitive effects:

@itemize @bullet
@item
Due to C's operator precedence, @code{2*x^2} would be parsed as @code{(2*x)^2}.
@item
Due to the binding of the operator @code{^}, @code{x^a^b} would result in
@code{(x^a)^b}. This would be confusing since most (though not all) other CAS
interpret this as @code{x^(a^b)}.
@item
Also, expressions involving integer exponents are very frequently used,
which makes it even more dangerous to overload @code{^} since it is then
hard to distinguish between the semantics as exponentiation and the one
for exclusive or.  (It would be embarassing to return @code{1} where one
has requested @code{2^3}.)
@end itemize

@cindex @command{ginsh}
All effects are contrary to mathematical notation and differ from the
way most other CAS handle exponentiation, therefore overloading @code{^}
is ruled out for GiNaC's C++ part.  The situation is different in
@command{ginsh}, there the exponentiation-@code{^} exists.  (Also note
that the other frequently used exponentiation operator @code{**} does
not exist at all in C++).

To be somewhat more precise, objects of the three classes described
here, are all containers for other expressions.  An object of class
@code{power} is best viewed as a container with two slots, one for the
basis, one for the exponent.  All valid GiNaC expressions can be
inserted.  However, basic transformations like simplifying
@code{pow(pow(x,2),3)} to @code{x^6} automatically are only performed
when this is mathematically possible.  If we replace the outer exponent
three in the example by some symbols @code{a}, the simplification is not
safe and will not be performed, since @code{a} might be @code{1/2} and
@code{x} negative.

Objects of type @code{add} and @code{mul} are containers with an
arbitrary number of slots for expressions to be inserted.  Again, simple
and safe simplifications are carried out like transforming
@code{3*x+4-x} to @code{2*x+4}.

The general rule is that when you construct such objects, GiNaC
automatically creates them in canonical form, which might differ from
the form you typed in your program.  This allows for rapid comparison of
expressions, since after all @code{a-a} is simply zero.  Note, that the
canonical form is not necessarily lexicographical ordering or in any way
easily guessable.  It is only guaranteed that constructing the same
expression twice, either implicitly or explicitly, results in the same
canonical form.


@node Lists, Mathematical functions, Fundamental containers, Basic Concepts
@c    node-name, next, previous, up
@section Lists of expressions
@cindex @code{lst} (class)
@cindex lists
@cindex @code{nops()}
@cindex @code{op()}
@cindex @code{append()}
@cindex @code{prepend()}

The GiNaC class @code{lst} serves for holding a list of arbitrary expressions.
These are sometimes used to supply a variable number of arguments of the same
type to GiNaC methods such as @code{subs()} and @code{to_rational()}, so you
should have a basic understanding about them.

Lists of up to 15 expressions can be directly constructed from single
expressions:

@example
@{
    symbol x("x"), y("y");
    lst l(x, 2, y, x+y);
    // now, l is a list holding the expressions 'x', '2', 'y', and 'x+y'
    // ...
@end example

Use the @code{nops()} method to determine the size (number of expressions) of
a list and the @code{op()} method to access individual elements:

@example
    // ...
    cout << l.nops() << endl;                   // prints '4'
    cout << l.op(2) << " " << l.op(0) << endl;  // prints 'y x'
    // ...
@end example

Finally you can append or prepend an expression to a list with the
@code{append()} and @code{prepend()} methods:

@example
    // ...
    l.append(4*x);   // l is now [x, 2, y, x+y, 4*x]
    l.prepend(0);    // l is now [0, x, 2, y, x+y, 4*x]
@}
@end example


@node Mathematical functions, Relations, Lists, Basic Concepts
@c    node-name, next, previous, up
@section Mathematical functions
@cindex @code{function} (class)
@cindex trigonometric function
@cindex hyperbolic function

There are quite a number of useful functions hard-wired into GiNaC.  For
instance, all trigonometric and hyperbolic functions are implemented
(@xref{Built-in Functions}, for a complete list).

These functions are all objects of class @code{function}.  They accept one
or more expressions as arguments and return one expression.  If the arguments
are not numerical, the evaluation of the function may be halted, as it
does in the next example:

@cindex Gamma function
@cindex @code{subs()}
@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y");
    
    ex foo = x+y/2;
    cout << "tgamma(" << foo << ") -> " << tgamma(foo) << endl;
    ex bar = foo.subs(y==1);
    cout << "tgamma(" << bar << ") -> " << tgamma(bar) << endl;
    ex foobar = bar.subs(x==7);
    cout << "tgamma(" << foobar << ") -> " << tgamma(foobar) << endl;
@}
@end example

This program shows how the function returns itself twice and finally an
expression that may be really useful:

@example
tgamma(x+(1/2)*y) -> tgamma(x+(1/2)*y)
tgamma(x+1/2) -> tgamma(x+1/2)
tgamma(15/2) -> (135135/128)*Pi^(1/2)
@end example

Besides evaluation most of these functions allow differentiation, series
expansion and so on.  Read the next chapter in order to learn more about
this.


@node Relations, Methods and Functions, Mathematical functions, Basic Concepts
@c    node-name, next, previous, up
@section Relations
@cindex @code{relational} (class)

Sometimes, a relation holding between two expressions must be stored
somehow.  The class @code{relational} is a convenient container for such
purposes.  A relation is by definition a container for two @code{ex} and
a relation between them that signals equality, inequality and so on.
They are created by simply using the C++ operators @code{==}, @code{!=},
@code{<}, @code{<=}, @code{>} and @code{>=} between two expressions.

@xref{Mathematical functions}, for examples where various applications
of the @code{.subs()} method show how objects of class relational are
used as arguments.  There they provide an intuitive syntax for
substitutions.  They are also used as arguments to the @code{ex::series}
method, where the left hand side of the relation specifies the variable
to expand in and the right hand side the expansion point.  They can also
be used for creating systems of equations that are to be solved for
unknown variables.  But the most common usage of objects of this class
is rather inconspicuous in statements of the form @code{if
(expand(pow(a+b,2))==a*a+2*a*b+b*b) @{...@}}.  Here, an implicit
conversion from @code{relational} to @code{bool} takes place.  Note,
however, that @code{==} here does not perform any simplifications, hence
@code{expand()} must be called explicitly.


@node Methods and Functions, Information About Expressions, Relations, Top
@c    node-name, next, previous, up
@chapter Methods and Functions
@cindex polynomial

In this chapter the most important algorithms provided by GiNaC will be
described.  Some of them are implemented as functions on expressions,
others are implemented as methods provided by expression objects.  If
they are methods, there exists a wrapper function around it, so you can
alternatively call it in a functional way as shown in the simple
example:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    ex x = numeric(1.0);
    
    cout << "As method:   " << sin(x).evalf() << endl;
    cout << "As function: " << evalf(sin(x)) << endl;
@}
@end example

@cindex @code{subs()}
The general rule is that wherever methods accept one or more parameters
(@var{arg1}, @var{arg2}, @dots{}) the order of arguments the function
wrapper accepts is the same but preceded by the object to act on
(@var{object}, @var{arg1}, @var{arg2}, @dots{}).  This approach is the
most natural one in an OO model but it may lead to confusion for MapleV
users because where they would type @code{A:=x+1; subs(x=2,A);} GiNaC
would require @code{A=x+1; subs(A,x==2);} (after proper declaration of
@code{A} and @code{x}).  On the other hand, since MapleV returns 3 on
@code{A:=x^2+3; coeff(A,x,0);} (GiNaC: @code{A=pow(x,2)+3;
coeff(A,x,0);}) it is clear that MapleV is not trying to be consistent
here.  Also, users of MuPAD will in most cases feel more comfortable
with GiNaC's convention.  All function wrappers are implemented
as simple inline functions which just call the corresponding method and
are only provided for users uncomfortable with OO who are dead set to
avoid method invocations.  Generally, nested function wrappers are much
harder to read than a sequence of methods and should therefore be
avoided if possible.  On the other hand, not everything in GiNaC is a
method on class @code{ex} and sometimes calling a function cannot be
avoided.

@menu
* Information About Expressions::
* Substituting Symbols::
* Polynomial Arithmetic::           Working with polynomials.
* Rational Expressions::            Working with rational functions.
* Symbolic Differentiation::
* Series Expansion::                Taylor and Laurent expansion.
* Built-in Functions::              List of predefined mathematical functions.
* Input/Output::                    Input and output of expressions.
@end menu


@node Information About Expressions, Substituting Symbols, Methods and Functions, Methods and Functions
@c    node-name, next, previous, up
@section Getting information about expressions

@subsection Checking expression types
@cindex @code{is_ex_of_type()}
@cindex @code{info()}

Sometimes it's useful to check whether a given expression is a plain number,
a sum, a polynomial with integer coefficients, or of some other specific type.
GiNaC provides two functions for this (the first one is actually a macro):

@example
bool is_ex_of_type(const ex & e, TYPENAME t);
bool ex::info(unsigned flag);
@end example

@code{is_ex_of_type()} allows you to check whether the top-level object of
an expression @samp{e} is an instance of the GiNaC class @samp{t}
(@xref{The Class Hierarchy}, for a list of all classes). This is most useful,
e.g., for checking whether an expression is a number, a sum, or a product:

@example
@{
    symbol x("x");
    ex e1 = 42;
    ex e2 = 4*x - 3;
    is_ex_of_type(e1, numeric);  // true
    is_ex_of_type(e2, numeric);  // false
    is_ex_of_type(e1, add);      // false
    is_ex_of_type(e2, add);      // true
    is_ex_of_type(e1, mul);      // false
    is_ex_of_type(e2, mul);      // false
@}
@end example

The @code{info()} method is used for checking certain attributes of
expressions. The possible values for the @code{flag} argument are defined
in @file{ginac/flags.h}, the most important being explained in the following
table:

@cartouche
@multitable @columnfractions .30 .70
@item @strong{Flag} @tab @strong{Returns true if the object is@dots{}}
@item @code{numeric}
@tab @dots{}a number (same as @code{is_ex_of_type(..., numeric)})
@item @code{real}
@tab @dots{}a real integer, rational or float (i.e. is not complex)
@item @code{rational}
@tab @dots{}an exact rational number (integers are rational, too)
@item @code{integer}
@tab @dots{}a (non-complex) integer
@item @code{crational}
@tab @dots{}an exact (complex) rational number (such as @math{2/3+7/2*I})
@item @code{cinteger}
@tab @dots{}a (complex) integer (such as @math{2-3*I})
@item @code{positive}
@tab @dots{}not complex and greater than 0
@item @code{negative}
@tab @dots{}not complex and less than 0
@item @code{nonnegative}
@tab @dots{}not complex and greater than or equal to 0
@item @code{posint}
@tab @dots{}an integer greater than 0
@item @code{negint}
@tab @dots{}an integer less than 0
@item @code{nonnegint}
@tab @dots{}an integer greater than or equal to 0
@item @code{even}
@tab @dots{}an even integer
@item @code{odd}
@tab @dots{}an odd integer
@item @code{prime}
@tab @dots{}a prime integer (probabilistic primality test)
@item @code{relation}
@tab @dots{}a relation (same as @code{is_ex_of_type(..., relational)})
@item @code{relation_equal}
@tab @dots{}a @code{==} relation
@item @code{relation_not_equal}
@tab @dots{}a @code{!=} relation
@item @code{relation_less}
@tab @dots{}a @code{<} relation
@item @code{relation_less_or_equal}
@tab @dots{}a @code{<=} relation
@item @code{relation_greater}
@tab @dots{}a @code{>} relation
@item @code{relation_greater_or_equal}
@tab @dots{}a @code{>=} relation
@item @code{symbol}
@tab @dots{}a symbol (same as @code{is_ex_of_type(..., symbol)})
@item @code{list}
@tab @dots{}a list (same as @code{is_ex_of_type(..., lst)})
@item @code{polynomial}
@tab @dots{}a polynomial (i.e. only consists of sums and products of numbers and symbols with positive integer powers)
@item @code{integer_polynomial}
@tab @dots{}a polynomial with (non-complex) integer coefficients
@item @code{cinteger_polynomial}
@tab @dots{}a polynomial with (possibly complex) integer coefficients (such as @math{2-3*I})
@item @code{rational_polynomial}
@tab @dots{}a polynomial with (non-complex) rational coefficients
@item @code{crational_polynomial}
@tab @dots{}a polynomial with (possibly complex) rational coefficients (such as @math{2/3+7/2*I})
@item @code{rational_function}
@tab @dots{}a rational function
@end multitable
@end cartouche


@subsection Accessing subexpressions
@cindex @code{nops()}
@cindex @code{op()}
@cindex @code{has()}
@cindex container
@cindex @code{relational} (class)

GiNaC provides the two methods

@example
unsigned ex::nops();
ex ex::op(unsigned i);
@end example

for accessing the subexpressions in the container-like GiNaC classes like
@code{add}, @code{mul}, @code{lst}, and @code{function}. @code{nops()}
determines the number of subexpressions (@samp{operands}) contained, while
@code{op()} returns the @code{i}-th (0..@code{nops()-1}) subexpression.
In the case of a @code{power} object, @code{op(0)} will return the basis
and @code{op(1)} the exponent.

The left-hand and right-hand side expressions of objects of class
@code{relational} (and only of these) can also be accessed with the methods

@example
ex ex::lhs();
ex ex::rhs();
@end example

Finally, the method

@example
bool ex::has(const ex & other);
@end example

checks whether an expression contains the given subexpression @code{other}.
This only works reliably if @code{other} is of an atomic class such as a
@code{numeric} or a @code{symbol}. It is, e.g., not possible to verify that
@code{a+b+c} contains @code{a+c} (or @code{a+b}) as a subexpression.


@subsection Comparing expressions
@cindex @code{is_equal()}
@cindex @code{is_zero()}

Expressions can be compared with the usual C++ relational operators like
@code{==}, @code{>}, and @code{<} but if the expressions contain symbols,
the result is usually not determinable and the result will be @code{false},
except in the case of the @code{!=} operator. You should also be aware that
GiNaC will only do the most trivial test for equality (subtracting both
expressions), so something like @code{(pow(x,2)+x)/x==x+1} will return
@code{false}.

Actually, if you construct an expression like @code{a == b}, this will be
represented by an object of the @code{relational} class (@xref{Relations}.)
which is not evaluated until (explicitly or implicitely) cast to a @code{bool}.

There are also two methods

@example
bool ex::is_equal(const ex & other);
bool ex::is_zero();
@end example

for checking whether one expression is equal to another, or equal to zero,
respectively.

@strong{Warning:} You will also find a @code{ex::compare()} method in the
GiNaC header files. This method is however only to be used internally by
GiNaC to establish a canonical sort order for terms, and using it to compare
expressions will give very surprising results.


@node Substituting Symbols, Polynomial Arithmetic, Information About Expressions, Methods and Functions
@c    node-name, next, previous, up
@section Substituting symbols
@cindex @code{subs()}

Symbols can be replaced with expressions via the @code{.subs()} method:

@example
ex ex::subs(const ex & e);
ex ex::subs(const lst & syms, const lst & repls);
@end example

In the first form, @code{subs()} accepts a relational of the form
@samp{symbol == expression} or a @code{lst} of such relationals. E.g.

@example
@{
    symbol x("x"), y("y");
    ex e1 = 2*x^2-4*x+3;
    cout << "e1(7) = " << e1.subs(x == 7) << endl;
    ex e2 = x*y + x;
    cout << "e2(-2, 4) = " << e2.subs(lst(x == -2, y == 4)) << endl;
@}
@end example

will print @samp{73} and @samp{-10}, respectively.

If you specify multiple substitutions, they are performed in parallel, so e.g.
@code{subs(lst(x == y, y == x))} exchanges @samp{x} and @samp{y}.

The second form of @code{subs()} takes two lists, one for the symbols and
one for the expressions to be substituted (both lists must contain the same
number of elements). Using this form, you would write @code{subs(lst(x, y), lst(y, x))}
to exchange @samp{x} and @samp{y}.


@node Polynomial Arithmetic, Rational Expressions, Substituting Symbols, Methods and Functions
@c    node-name, next, previous, up
@section Polynomial arithmetic

@subsection Expanding and collecting
@cindex @code{expand()}
@cindex @code{collect()}

A polynomial in one or more variables has many equivalent
representations.  Some useful ones serve a specific purpose.  Consider
for example the trivariate polynomial @math{4*x*y + x*z + 20*y^2 +
21*y*z + 4*z^2} (written down here in output-style).  It is equivalent
to the factorized polynomial @math{(x + 5*y + 4*z)*(4*y + z)}.  Other
representations are the recursive ones where one collects for exponents
in one of the three variable.  Since the factors are themselves
polynomials in the remaining two variables the procedure can be
repeated.  In our expample, two possibilities would be @math{(4*y + z)*x
+ 20*y^2 + 21*y*z + 4*z^2} and @math{20*y^2 + (21*z + 4*x)*y + 4*z^2 +
x*z}.

To bring an expression into expanded form, its method

@example
ex ex::expand();
@end example

may be called.  In our example above, this corresponds to @math{4*x*y +
x*z + 20*y^2 + 21*y*z + 4*z^2}.  Again, since the canonical form in
GiNaC is not easily guessable you should be prepared to see different
orderings of terms in such sums!

Another useful representation of multivariate polynomials is as a
univariate polynomial in one of the variables with the coefficients
being polynomials in the remaining variables.  The method
@code{collect()} accomplishes this task:

@example
ex ex::collect(const symbol & s);
@end example

Note that the original polynomial needs to be in expanded form in order
to be able to find the coefficients properly.

@subsection Degree and coefficients
@cindex @code{degree()}
@cindex @code{ldegree()}
@cindex @code{coeff()}

The degree and low degree of a polynomial can be obtained using the two
methods

@example
int ex::degree(const symbol & s);
int ex::ldegree(const symbol & s);
@end example

which also work reliably on non-expanded input polynomials (they even work
on rational functions, returning the asymptotic degree). To extract
a coefficient with a certain power from an expanded polynomial you use

@example
ex ex::coeff(const symbol & s, int n);
@end example

You can also obtain the leading and trailing coefficients with the methods

@example
ex ex::lcoeff(const symbol & s);
ex ex::tcoeff(const symbol & s);
@end example

which are equivalent to @code{coeff(s, degree(s))} and @code{coeff(s, ldegree(s))},
respectively.

An application is illustrated in the next example, where a multivariate
polynomial is analyzed:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y");
    ex PolyInp = 4*pow(x,3)*y + 5*x*pow(y,2) + 3*y
                 - pow(x+y,2) + 2*pow(y+2,2) - 8;
    ex Poly = PolyInp.expand();
    
    for (int i=Poly.ldegree(x); i<=Poly.degree(x); ++i) @{
        cout << "The x^" << i << "-coefficient is "
             << Poly.coeff(x,i) << endl;
    @}
    cout << "As polynomial in y: " 
         << Poly.collect(y) << endl;
@}
@end example

When run, it returns an output in the following fashion:

@example
The x^0-coefficient is y^2+11*y
The x^1-coefficient is 5*y^2-2*y
The x^2-coefficient is -1
The x^3-coefficient is 4*y
As polynomial in y: -x^2+(5*x+1)*y^2+(-2*x+4*x^3+11)*y
@end example

As always, the exact output may vary between different versions of GiNaC
or even from run to run since the internal canonical ordering is not
within the user's sphere of influence.


@subsection Polynomial division
@cindex polynomial division
@cindex quotient
@cindex remainder
@cindex pseudo-remainder
@cindex @code{quo()}
@cindex @code{rem()}
@cindex @code{prem()}
@cindex @code{divide()}

The two functions

@example
ex quo(const ex & a, const ex & b, const symbol & x);
ex rem(const ex & a, const ex & b, const symbol & x);
@end example

compute the quotient and remainder of univariate polynomials in the variable
@samp{x}. The results satisfy @math{a = b*quo(a, b, x) + rem(a, b, x)}.

The additional function

@example
ex prem(const ex & a, const ex & b, const symbol & x);
@end example

computes the pseudo-remainder of @samp{a} and @samp{b} which satisfies
@math{c*a = b*q + prem(a, b, x)}, where @math{c = b.lcoeff(x) ^ (a.degree(x) - b.degree(x) + 1)}.

Exact division of multivariate polynomials is performed by the function

@example
bool divide(const ex & a, const ex & b, ex & q);
@end example

If @samp{b} divides @samp{a} over the rationals, this function returns @code{true}
and returns the quotient in the variable @code{q}. Otherwise it returns @code{false}
in which case the value of @code{q} is undefined.


@subsection Unit, content and primitive part
@cindex @code{unit()}
@cindex @code{content()}
@cindex @code{primpart()}

The methods

@example
ex ex::unit(const symbol & x);
ex ex::content(const symbol & x);
ex ex::primpart(const symbol & x);
@end example

return the unit part, content part, and primitive polynomial of a multivariate
polynomial with respect to the variable @samp{x} (the unit part being the sign
of the leading coefficient, the content part being the GCD of the coefficients,
and the primitive polynomial being the input polynomial divided by the unit and
content parts). The product of unit, content, and primitive part is the
original polynomial.


@subsection GCD and LCM
@cindex GCD
@cindex LCM
@cindex @code{gcd()}
@cindex @code{lcm()}

The functions for polynomial greatest common divisor and least common
multiple have the synopsis

@example
ex gcd(const ex & a, const ex & b);
ex lcm(const ex & a, const ex & b);
@end example

The functions @code{gcd()} and @code{lcm()} accept two expressions
@code{a} and @code{b} as arguments and return a new expression, their
greatest common divisor or least common multiple, respectively.  If the
polynomials @code{a} and @code{b} are coprime @code{gcd(a,b)} returns 1
and @code{lcm(a,b)} returns the product of @code{a} and @code{b}.

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y"), z("z");
    ex P_a = 4*x*y + x*z + 20*pow(y, 2) + 21*y*z + 4*pow(z, 2);
    ex P_b = x*y + 3*x*z + 5*pow(y, 2) + 19*y*z + 12*pow(z, 2);

    ex P_gcd = gcd(P_a, P_b);
    // x + 5*y + 4*z
    ex P_lcm = lcm(P_a, P_b);
    // 4*x*y^2 + 13*y*x*z + 20*y^3 + 81*y^2*z + 67*y*z^2 + 3*x*z^2 + 12*z^3
@}
@end example


@node Rational Expressions, Symbolic Differentiation, Polynomial Arithmetic, Methods and Functions
@c    node-name, next, previous, up
@section Rational expressions

@subsection The @code{normal} method
@cindex @code{normal()}
@cindex simplification
@cindex temporary replacement

Some basic from of simplification of expressions is called for frequently.
GiNaC provides the method @code{.normal()}, which converts a rational function
into an equivalent rational function of the form @samp{numerator/denominator}
where numerator and denominator are coprime.  If the input expression is already
a fraction, it just finds the GCD of numerator and denominator and cancels it,
otherwise it performs fraction addition and multiplication.

@code{.normal()} can also be used on expressions which are not rational functions
as it will replace all non-rational objects (like functions or non-integer
powers) by temporary symbols to bring the expression to the domain of rational
functions before performing the normalization, and re-substituting these
symbols afterwards. This algorithm is also available as a separate method
@code{.to_rational()}, described below.

This means that both expressions @code{t1} and @code{t2} are indeed
simplified in this little program:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x");
    ex t1 = (pow(x,2) + 2*x + 1)/(x + 1);
    ex t2 = (pow(sin(x),2) + 2*sin(x) + 1)/(sin(x) + 1);
    cout << "t1 is " << t1.normal() << endl;
    cout << "t2 is " << t2.normal() << endl;
@}
@end example

Of course this works for multivariate polynomials too, so the ratio of
the sample-polynomials from the section about GCD and LCM above would be
normalized to @code{P_a/P_b} = @code{(4*y+z)/(y+3*z)}.


@subsection Numerator and denominator
@cindex numerator
@cindex denominator
@cindex @code{numer()}
@cindex @code{denom()}

The numerator and denominator of an expression can be obtained with

@example
ex ex::numer();
ex ex::denom();
@end example

These functions will first normalize the expression as described above and
then return the numerator or denominator, respectively.


@subsection Converting to a rational expression
@cindex @code{to_rational()}

Some of the methods described so far only work on polynomials or rational
functions. GiNaC provides a way to extend the domain of these functions to
general expressions by using the temporary replacement algorithm described
above. You do this by calling

@example
ex ex::to_rational(lst &l);
@end example

on the expression to be converted. The supplied @code{lst} will be filled
with the generated temporary symbols and their replacement expressions in
a format that can be used directly for the @code{subs()} method. It can also
already contain a list of replacements from an earlier application of
@code{.to_rational()}, so it's possible to use it on multiple expressions
and get consistent results.

For example,

@example
@{
    symbol x("x");
    ex a = pow(sin(x), 2) - pow(cos(x), 2);
    ex b = sin(x) + cos(x);
    ex q;
    lst l;
    divide(a.to_rational(l), b.to_rational(l), q);
    cout << q.subs(l) << endl;
@}
@end example

will print @samp{sin(x)-cos(x)}.


@node Symbolic Differentiation, Series Expansion, Rational Expressions, Methods and Functions
@c    node-name, next, previous, up
@section Symbolic differentiation
@cindex differentiation
@cindex @code{diff()}
@cindex chain rule
@cindex product rule

GiNaC's objects know how to differentiate themselves.  Thus, a
polynomial (class @code{add}) knows that its derivative is the sum of
the derivatives of all the monomials:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y"), z("z");
    ex P = pow(x, 5) + pow(x, 2) + y;

    cout << P.diff(x,2) << endl;  // 20*x^3 + 2
    cout << P.diff(y) << endl;    // 1
    cout << P.diff(z) << endl;    // 0
@}
@end example

If a second integer parameter @var{n} is given, the @code{diff} method
returns the @var{n}th derivative.

If @emph{every} object and every function is told what its derivative
is, all derivatives of composed objects can be calculated using the
chain rule and the product rule.  Consider, for instance the expression
@code{1/cosh(x)}.  Since the derivative of @code{cosh(x)} is
@code{sinh(x)} and the derivative of @code{pow(x,-1)} is
@code{-pow(x,-2)}, GiNaC can readily compute the composition.  It turns
out that the composition is the generating function for Euler Numbers,
i.e. the so called @var{n}th Euler number is the coefficient of
@code{x^n/n!} in the expansion of @code{1/cosh(x)}.  We may use this
identity to code a function that generates Euler numbers in just three
lines:

@cindex Euler numbers
@example
#include <ginac/ginac.h>
using namespace GiNaC;

ex EulerNumber(unsigned n)
@{
    symbol x;
    const ex generator = pow(cosh(x),-1);
    return generator.diff(x,n).subs(x==0);
@}

int main()
@{
    for (unsigned i=0; i<11; i+=2)
        cout << EulerNumber(i) << endl;
    return 0;
@}
@end example

When you run it, it produces the sequence @code{1}, @code{-1}, @code{5},
@code{-61}, @code{1385}, @code{-50521}.  We increment the loop variable
@code{i} by two since all odd Euler numbers vanish anyways.


@node Series Expansion, Built-in Functions, Symbolic Differentiation, Methods and Functions
@c    node-name, next, previous, up
@section Series expansion
@cindex @code{series()}
@cindex Taylor expansion
@cindex Laurent expansion
@cindex @code{pseries} (class)

Expressions know how to expand themselves as a Taylor series or (more
generally) a Laurent series.  As in most conventional Computer Algebra
Systems, no distinction is made between those two.  There is a class of
its own for storing such series (@code{class pseries}) and a built-in
function (called @code{Order}) for storing the order term of the series.
As a consequence, if you want to work with series, i.e. multiply two
series, you need to call the method @code{ex::series} again to convert
it to a series object with the usual structure (expansion plus order
term).  A sample application from special relativity could read:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol v("v"), c("c");
    
    ex gamma = 1/sqrt(1 - pow(v/c,2));
    ex mass_nonrel = gamma.series(v==0, 10);
    
    cout << "the relativistic mass increase with v is " << endl
         << mass_nonrel << endl;
    
    cout << "the inverse square of this series is " << endl
         << pow(mass_nonrel,-2).series(v==0, 10) << endl;
@}
@end example

Only calling the series method makes the last output simplify to
@math{1-v^2/c^2+O(v^10)}, without that call we would just have a long
series raised to the power @math{-2}.

@cindex M@'echain's formula
As another instructive application, let us calculate the numerical 
value of Archimedes' constant
@tex
$\pi$
@end tex
(for which there already exists the built-in constant @code{Pi}) 
using M@'echain's amazing formula
@tex
$\pi=16$~atan~$\!\left(1 \over 5 \right)-4$~atan~$\!\left(1 \over 239 \right)$.
@end tex
@ifnottex
@math{Pi==16*atan(1/5)-4*atan(1/239)}.
@end ifnottex
We may expand the arcus tangent around @code{0} and insert the fractions
@code{1/5} and @code{1/239}.  But, as we have seen, a series in GiNaC
carries an order term with it and the question arises what the system is
supposed to do when the fractions are plugged into that order term.  The
solution is to use the function @code{series_to_poly()} to simply strip
the order term off:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

ex mechain_pi(int degr)
@{
    symbol x;
    ex pi_expansion = series_to_poly(atan(x).series(x,degr));
    ex pi_approx = 16*pi_expansion.subs(x==numeric(1,5))
                   -4*pi_expansion.subs(x==numeric(1,239));
    return pi_approx;
@}

int main()
@{
    ex pi_frac;
    for (int i=2; i<12; i+=2) @{
        pi_frac = mechain_pi(i);
        cout << i << ":\t" << pi_frac << endl
             << "\t" << pi_frac.evalf() << endl;
    @}
    return 0;
@}
@end example

Note how we just called @code{.series(x,degr)} instead of
@code{.series(x==0,degr)}.  This is a simple shortcut for @code{ex}'s
method @code{series()}: if the first argument is a symbol the expression
is expanded in that symbol around point @code{0}.  When you run this
program, it will type out:

@example
2:      3804/1195
        3.1832635983263598326
4:      5359397032/1706489875
        3.1405970293260603143
6:      38279241713339684/12184551018734375
        3.141621029325034425
8:      76528487109180192540976/24359780855939418203125
        3.141591772182177295
10:     327853873402258685803048818236/104359128170408663038552734375
        3.1415926824043995174
@end example


@node Built-in Functions, Input/Output, Series Expansion, Methods and Functions
@c    node-name, next, previous, up
@section Predefined mathematical functions

GiNaC contains the following predefined mathematical functions:

@cartouche
@multitable @columnfractions .30 .70
@item @strong{Name} @tab @strong{Function}
@item @code{abs(x)}
@tab absolute value
@item @code{csgn(x)}
@tab complex sign
@item @code{sqrt(x)}
@tab square root (not a GiNaC function proper but equivalent to @code{pow(x, numeric(1, 2)})
@item @code{sin(x)}
@tab sine
@item @code{cos(x)}
@tab cosine
@item @code{tan(x)}
@tab tangent
@item @code{asin(x)}
@tab inverse sine
@item @code{acos(x)}
@tab inverse cosine
@item @code{atan(x)}
@tab inverse tangent
@item @code{atan2(y, x)}
@tab inverse tangent with two arguments
@item @code{sinh(x)}
@tab hyperbolic sine
@item @code{cosh(x)}
@tab hyperbolic cosine
@item @code{tanh(x)}
@tab hyperbolic tangent
@item @code{asinh(x)}
@tab inverse hyperbolic sine
@item @code{acosh(x)}
@tab inverse hyperbolic cosine
@item @code{atanh(x)}
@tab inverse hyperbolic tangent
@item @code{exp(x)}
@tab exponential function
@item @code{log(x)}
@tab natural logarithm
@item @code{zeta(x)}
@tab Riemann's zeta function
@item @code{zeta(n, x)}
@tab derivatives of Riemann's zeta function
@item @code{tgamma(x)}
@tab Gamma function
@item @code{lgamma(x)}
@tab logarithm of Gamma function
@item @code{beta(x, y)}
@tab Beta function (@code{tgamma(x)*tgamma(y)/tgamma(x+y)})
@item @code{psi(x)}
@tab psi (digamma) function
@item @code{psi(n, x)}
@tab derivatives of psi function (polygamma functions)
@item @code{factorial(n)}
@tab factorial function
@item @code{binomial(n, m)}
@tab binomial coefficients
@item @code{Order(x)}
@tab order term function in truncated power series
@item @code{Derivative(x, l)}
@tab inert partial differentiation operator (used internally)
@end multitable
@end cartouche

@cindex branch cut
For functions that have a branch cut in the complex plane GiNaC follows
the conventions for C++ as defined in the ANSI standard.  In particular:
the natural logarithm (@code{log}) and the square root (@code{sqrt})
both have their branch cuts running along the negative real axis where
the points on the axis itself belong to the upper part.


@node Input/Output, Extending GiNaC, Built-in Functions, Methods and Functions
@c    node-name, next, previous, up
@section Input and output of expressions
@cindex I/O

@subsection Expression output
@cindex printing
@cindex output of expressions

The easiest way to print an expression is to write it to a stream:

@example
@{
    symbol x("x");
    ex e = 4.5+pow(x,2)*3/2;
    cout << e << endl;    // prints '4.5+3/2*x^2'
    // ...
@end example

The output format is identical to the @command{ginsh} input syntax and
to that used by most computer algebra systems, but not directly pastable
into a GiNaC C++ program (note that in the above example, @code{pow(x,2)}
is printed as @samp{x^2}).

To print an expression in a way that can be directly used in a C or C++
program, you use the method

@example
void ex::printcsrc(ostream & os, unsigned type, const char *name);
@end example

This outputs a line in the form of a variable definition @code{<type> <name> = <expression>}.
The possible types are defined in @file{ginac/flags.h} (@code{csrc_types})
and mostly affect the way in which floating point numbers are written:

@example
    // ...
    e.printcsrc(cout, csrc_types::ctype_float, "f");
    e.printcsrc(cout, csrc_types::ctype_double, "d");
    e.printcsrc(cout, csrc_types::ctype_cl_N, "n");
    // ...
@end example

The above example will produce (note the @code{x^2} being converted to @code{x*x}):

@example
float f = (3.000000e+00/2.000000e+00)*(x*x)+4.500000e+00;
double d = (3.000000e+00/2.000000e+00)*(x*x)+4.500000e+00;
cl_N n = (cl_F("3.0")/cl_F("2.0"))*(x*x)+cl_F("4.5");
@end example

Finally, there are the two methods @code{printraw()} and @code{printtree()} intended for GiNaC
developers, that provide a dump of the internal structure of an expression for
debugging purposes:

@example
    // ...
    e.printraw(cout); cout << endl << endl;
    e.printtree(cout);
@}
@end example

produces

@example
ex(+((power(ex(symbol(name=x,serial=1,hash=150875740,flags=11)),ex(numeric(2)),hash=2,flags=3),numeric(3/2)),,hash=0,flags=3))

type=Q25GiNaC3add, hash=0 (0x0), flags=3, nops=2
    power: hash=2 (0x2), flags=3
        x (symbol): serial=1, hash=150875740 (0x8fe2e5c), flags=11
        2 (numeric): hash=2147483714 (0x80000042), flags=11
    3/2 (numeric): hash=2147483745 (0x80000061), flags=11
    -----
    overall_coeff
    4.5L0 (numeric): hash=2147483723 (0x8000004b), flags=11
    =====
@end example

The @code{printtree()} method is also available in @command{ginsh} as the
@code{print()} function.


@subsection Expression input
@cindex input of expressions

GiNaC provides no way to directly read an expression from a stream because
you will usually want the user to be able to enter something like @samp{2*x+sin(y)}
and have the @samp{x} and @samp{y} correspond to the symbols @code{x} and
@code{y} you defined in your program and there is no way to specify the
desired symbols to the @code{>>} stream input operator.

Instead, GiNaC lets you construct an expression from a string, specifying the
list of symbols to be used:

@example
@{
    symbol x("x"), y("y");
    ex e("2*x+sin(y)", lst(x, y));
@}
@end example

The input syntax is the same as that used by @command{ginsh} and the stream
output operator @code{<<}. The symbols in the string are matched by name to
the symbols in the list and if GiNaC encounters a symbol not specified in
the list it will throw an exception.

With this constructor, it's also easy to implement interactive GiNaC programs:

@example
#include <iostream>
#include <string>
#include <stdexcept>
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
     symbol x("x");
     string s;

     cout << "Enter an expression containing 'x': ";
     getline(cin, s);

     try @{
         ex e(s, lst(x));
         cout << "The derivative of " << e << " with respect to x is ";
         cout << e.diff(x) << ".\n";
     @} catch (exception &p) @{
         cerr << p.what() << endl;
     @}
@}
@end example


@subsection Archiving
@cindex @code{archive} (class)
@cindex archiving

GiNaC allows creating @dfn{archives} of expressions which can be stored
to or retrieved from files. To create an archive, you declare an object
of class @code{archive} and archive expressions in it, giving each
expression a unique name:

@example
#include <ginac/ginac.h>
#include <fstream>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y"), z("z");

    ex foo = sin(x + 2*y) + 3*z + 41;
    ex bar = foo + 1;

    archive a;
    a.archive_ex(foo, "foo");
    a.archive_ex(bar, "the second one");
    // ...
@end example

The archive can then be written to a file:

@example
    // ...
    ofstream out("foobar.gar");
    out << a;
    out.close();
    // ...
@end example

The file @file{foobar.gar} contains all information that is needed to
reconstruct the expressions @code{foo} and @code{bar}.

@cindex @command{viewgar}
The tool @command{viewgar} that comes with GiNaC can be used to view
the contents of GiNaC archive files:

@example
$ viewgar foobar.gar
foo = 41+sin(x+2*y)+3*z
the second one = 42+sin(x+2*y)+3*z
@end example

The point of writing archive files is of course that they can later be
read in again:

@example
    // ...
    archive a2;
    ifstream in("foobar.gar");
    in >> a2;
    // ...
@end example

And the stored expressions can be retrieved by their name:

@example
    // ...
    lst syms(x, y);

    ex ex1 = a2.unarchive_ex(syms, "foo");
    ex ex2 = a2.unarchive_ex(syms, "the second one");

    cout << ex1 << endl;              // prints "41+sin(x+2*y)+3*z"
    cout << ex2 << endl;              // prints "42+sin(x+2*y)+3*z"
    cout << ex1.subs(x == 2) << endl; // prints "41+sin(2+2*y)+3*z"
@}
@end example

Note that you have to supply a list of the symbols which are to be inserted
in the expressions. Symbols in archives are stored by their name only and
if you don't specify which symbols you have, unarchiving the expression will
create new symbols with that name. E.g. if you hadn't included @code{x} in
the @code{syms} list above, the @code{ex1.subs(x == 2)} statement would
have had no effect because the @code{x} in @code{ex1} would have been a
different symbol than the @code{x} which was defined at the beginning of
the program, altough both would appear as @samp{x} when printed.



@node Extending GiNaC, What does not belong into GiNaC, Input/Output, Top
@c    node-name, next, previous, up
@chapter Extending GiNaC

By reading so far you should have gotten a fairly good understanding of
GiNaC's design-patterns.  From here on you should start reading the
sources.  All we can do now is issue some recommendations how to tackle
GiNaC's many loose ends in order to fulfill everybody's dreams.  If you
develop some useful extension please don't hesitate to contact the GiNaC
authors---they will happily incorporate them into future versions.

@menu
* What does not belong into GiNaC::  What to avoid.
* Symbolic functions::               Implementing symbolic functions.
@end menu


@node What does not belong into GiNaC, Symbolic functions, Extending GiNaC, Extending GiNaC
@c    node-name, next, previous, up
@section What doesn't belong into GiNaC

@cindex @command{ginsh}
First of all, GiNaC's name must be read literally.  It is designed to be
a library for use within C++.  The tiny @command{ginsh} accompanying
GiNaC makes this even more clear: it doesn't even attempt to provide a
language.  There are no loops or conditional expressions in
@command{ginsh}, it is merely a window into the library for the
programmer to test stuff (or to show off).  Still, the design of a
complete CAS with a language of its own, graphical capabilites and all
this on top of GiNaC is possible and is without doubt a nice project for
the future.

There are many built-in functions in GiNaC that do not know how to
evaluate themselves numerically to a precision declared at runtime
(using @code{Digits}).  Some may be evaluated at certain points, but not
generally.  This ought to be fixed.  However, doing numerical
computations with GiNaC's quite abstract classes is doomed to be
inefficient.  For this purpose, the underlying foundation classes
provided by @acronym{CLN} are much better suited.


@node Symbolic functions, A Comparison With Other CAS, What does not belong into GiNaC, Extending GiNaC
@c    node-name, next, previous, up
@section Symbolic functions

The easiest and most instructive way to start with is probably to
implement your own function.  Objects of class @code{function} are
inserted into the system via a kind of `registry'.  They get a serial
number that is used internally to identify them but you usually need not
worry about this.  What you have to care for are functions that are
called when the user invokes certain methods.  These are usual
C++-functions accepting a number of @code{ex} as arguments and returning
one @code{ex}.  As an example, if we have a look at a simplified
implementation of the cosine trigonometric function, we first need a
function that is called when one wishes to @code{eval} it.  It could
look something like this:

@example
static ex cos_eval_method(const ex & x)
@{
    // if (!x%(2*Pi)) return 1
    // if (!x%Pi) return -1
    // if (!x%Pi/2) return 0
    // care for other cases...
    return cos(x).hold();
@}
@end example

@cindex @code{hold()}
@cindex evaluation
The last line returns @code{cos(x)} if we don't know what else to do and
stops a potential recursive evaluation by saying @code{.hold()}, which
sets a flag to the expression signaling that it has been evaluated.  We
should also implement a method for numerical evaluation and since we are
lazy we sweep the problem under the rug by calling someone else's
function that does so, in this case the one in class @code{numeric}:

@example
static ex cos_evalf(const ex & x)
@{
    return cos(ex_to_numeric(x));
@}
@end example

Differentiation will surely turn up and so we need to tell @code{cos}
what the first derivative is (higher derivatives (@code{.diff(x,3)} for
instance are then handled automatically by @code{basic::diff} and
@code{ex::diff}):

@example
static ex cos_deriv(const ex & x, unsigned diff_param)
@{
    return -sin(x);
@}
@end example

@cindex product rule
The second parameter is obligatory but uninteresting at this point.  It
specifies which parameter to differentiate in a partial derivative in
case the function has more than one parameter and its main application
is for correct handling of the chain rule.  For Taylor expansion, it is
enough to know how to differentiate.  But if the function you want to
implement does have a pole somewhere in the complex plane, you need to
write another method for Laurent expansion around that point.

Now that all the ingrediences for @code{cos} have been set up, we need
to tell the system about it.  This is done by a macro and we are not
going to descibe how it expands, please consult your preprocessor if you
are curious:

@example
REGISTER_FUNCTION(cos, eval_func(cos_eval).
                       evalf_func(cos_evalf).
                       derivative_func(cos_deriv));
@end example

The first argument is the function's name used for calling it and for
output.  The second binds the corresponding methods as options to this
object.  Options are separated by a dot and can be given in an arbitrary
order.  GiNaC functions understand several more options which are always
specified as @code{.option(params)}, for example a method for series
expansion @code{.series_func(cos_series)}.  Again, if no series
expansion method is given, GiNaC defaults to simple Taylor expansion,
which is correct if there are no poles involved as is the case for the
@code{cos} function.  The way GiNaC handles poles in case there are any
is best understood by studying one of the examples, like the Gamma
(@code{tgamma}) function for instance.  (In essence the function first
checks if there is a pole at the evaluation point and falls back to
Taylor expansion if there isn't.  Then, the pole is regularized by some
suitable transformation.)  Also, the new function needs to be declared
somewhere.  This may also be done by a convenient preprocessor macro:

@example
DECLARE_FUNCTION_1P(cos)
@end example

The suffix @code{_1P} stands for @emph{one parameter}.  Of course, this
implementation of @code{cos} is very incomplete and lacks several safety
mechanisms.  Please, have a look at the real implementation in GiNaC.
(By the way: in case you are worrying about all the macros above we can
assure you that functions are GiNaC's most macro-intense classes.  We
have done our best to avoid macros where we can.)

That's it. May the source be with you!


@node A Comparison With Other CAS, Advantages, Symbolic functions, Top
@c    node-name, next, previous, up
@chapter A Comparison With Other CAS
@cindex advocacy

This chapter will give you some information on how GiNaC compares to
other, traditional Computer Algebra Systems, like @emph{Maple},
@emph{Mathematica} or @emph{Reduce}, where it has advantages and
disadvantages over these systems.

@menu
* Advantages::                       Stengths of the GiNaC approach.
* Disadvantages::                    Weaknesses of the GiNaC approach.
* Why C++?::                         Attractiveness of C++.
@end menu

@node Advantages, Disadvantages, A Comparison With Other CAS, A Comparison With Other CAS
@c    node-name, next, previous, up
@section Advantages

GiNaC has several advantages over traditional Computer
Algebra Systems, like 

@itemize @bullet

@item
familiar language: all common CAS implement their own proprietary
grammar which you have to learn first (and maybe learn again when your
vendor decides to `enhance' it).  With GiNaC you can write your program
in common C++, which is standardized.

@cindex STL
@item
structured data types: you can build up structured data types using
@code{struct}s or @code{class}es together with STL features instead of
using unnamed lists of lists of lists.

@item
strongly typed: in CAS, you usually have only one kind of variables
which can hold contents of an arbitrary type.  This 4GL like feature is
nice for novice programmers, but dangerous.
    
@item
development tools: powerful development tools exist for C++, like fancy
editors (e.g. with automatic indentation and syntax highlighting),
debuggers, visualization tools, documentation generators...

@item
modularization: C++ programs can easily be split into modules by
separating interface and implementation.

@item
price: GiNaC is distributed under the GNU Public License which means
that it is free and available with source code.  And there are excellent
C++-compilers for free, too.
    
@item
extendable: you can add your own classes to GiNaC, thus extending it on
a very low level.  Compare this to a traditional CAS that you can
usually only extend on a high level by writing in the language defined
by the parser.  In particular, it turns out to be almost impossible to
fix bugs in a traditional system.

@item
multiple interfaces: Though real GiNaC programs have to be written in
some editor, then be compiled, linked and executed, there are more ways
to work with the GiNaC engine.  Many people want to play with
expressions interactively, as in traditional CASs.  Currently, two such
windows into GiNaC have been implemented and many more are possible: the
tiny @command{ginsh} that is part of the distribution exposes GiNaC's
types to a command line and second, as a more consistent approach, an
interactive interface to the @acronym{Cint} C++ interpreter has been put
together (called @acronym{GiNaC-cint}) that allows an interactive
scripting interface consistent with the C++ language.

@item
seemless integration: it is somewhere between difficult and impossible
to call CAS functions from within a program written in C++ or any other
programming language and vice versa.  With GiNaC, your symbolic routines
are part of your program.  You can easily call third party libraries,
e.g. for numerical evaluation or graphical interaction.  All other
approaches are much more cumbersome: they range from simply ignoring the
problem (i.e. @emph{Maple}) to providing a method for `embedding' the
system (i.e. @emph{Yacas}).

@item
efficiency: often large parts of a program do not need symbolic
calculations at all.  Why use large integers for loop variables or
arbitrary precision arithmetics where @code{int} and @code{double} are
sufficient?  For pure symbolic applications, GiNaC is comparable in
speed with other CAS.

@end itemize


@node Disadvantages, Why C++?, Advantages, A Comparison With Other CAS
@c    node-name, next, previous, up
@section Disadvantages

Of course it also has some disadvantages:

@itemize @bullet

@item
advanced features: GiNaC cannot compete with a program like
@emph{Reduce} which exists for more than 30 years now or @emph{Maple}
which grows since 1981 by the work of dozens of programmers, with
respect to mathematical features.  Integration, factorization,
non-trivial simplifications, limits etc. are missing in GiNaC (and are
not planned for the near future).

@item
portability: While the GiNaC library itself is designed to avoid any
platform dependent features (it should compile on any ANSI compliant C++
compiler), the currently used version of the CLN library (fast large
integer and arbitrary precision arithmetics) can be compiled only on
systems with a recently new C++ compiler from the GNU Compiler
Collection (@acronym{GCC}).@footnote{This is because CLN uses
PROVIDE/REQUIRE like macros to let the compiler gather all static
initializations, which works for GNU C++ only.}  GiNaC uses recent
language features like explicit constructors, mutable members, RTTI,
@code{dynamic_cast}s and STL, so ANSI compliance is meant literally.
Recent @acronym{GCC} versions starting at 2.95, although itself not yet
ANSI compliant, support all needed features.
    
@end itemize


@node Why C++?, Internal Structures, Disadvantages, A Comparison With Other CAS
@c    node-name, next, previous, up
@section Why C++?

Why did we choose to implement GiNaC in C++ instead of Java or any other
language?  C++ is not perfect: type checking is not strict (casting is
possible), separation between interface and implementation is not
complete, object oriented design is not enforced.  The main reason is
the often scolded feature of operator overloading in C++.  While it may
be true that operating on classes with a @code{+} operator is rarely
meaningful, it is perfectly suited for algebraic expressions.  Writing
@math{3x+5y} as @code{3*x+5*y} instead of
@code{x.times(3).plus(y.times(5))} looks much more natural.
Furthermore, the main developers are more familiar with C++ than with
any other programming language.


@node Internal Structures, Expressions are reference counted, Why C++? , Top
@c    node-name, next, previous, up
@appendix Internal Structures

@menu
* Expressions are reference counted::
* Internal representation of products and sums::
@end menu

@node Expressions are reference counted, Internal representation of products and sums, Internal Structures, Internal Structures
@c    node-name, next, previous, up
@appendixsection Expressions are reference counted

@cindex reference counting
@cindex copy-on-write
@cindex garbage collection
An expression is extremely light-weight since internally it works like a
handle to the actual representation and really holds nothing more than a
pointer to some other object. What this means in practice is that
whenever you create two @code{ex} and set the second equal to the first
no copying process is involved. Instead, the copying takes place as soon
as you try to change the second.  Consider the simple sequence of code:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y"), z("z");
    ex e1, e2;

    e1 = sin(x + 2*y) + 3*z + 41;
    e2 = e1;                // e2 points to same object as e1
    cout << e2 << endl;     // prints sin(x+2*y)+3*z+41
    e2 += 1;                // e2 is copied into a new object
    cout << e2 << endl;     // prints sin(x+2*y)+3*z+42
@}
@end example

The line @code{e2 = e1;} creates a second expression pointing to the
object held already by @code{e1}.  The time involved for this operation
is therefore constant, no matter how large @code{e1} was.  Actual
copying, however, must take place in the line @code{e2 += 1;} because
@code{e1} and @code{e2} are not handles for the same object any more.
This concept is called @dfn{copy-on-write semantics}.  It increases
performance considerably whenever one object occurs multiple times and
represents a simple garbage collection scheme because when an @code{ex}
runs out of scope its destructor checks whether other expressions handle
the object it points to too and deletes the object from memory if that
turns out not to be the case.  A slightly less trivial example of
differentiation using the chain-rule should make clear how powerful this
can be:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y");

    ex e1 = x + 3*y;
    ex e2 = pow(e1, 3);
    ex e3 = diff(sin(e2), x);   // first derivative of sin(e2) by x
    cout << e1 << endl          // prints x+3*y
         << e2 << endl          // prints (x+3*y)^3
         << e3 << endl;         // prints 3*(x+3*y)^2*cos((x+3*y)^3)
@}
@end example

Here, @code{e1} will actually be referenced three times while @code{e2}
will be referenced two times.  When the power of an expression is built,
that expression needs not be copied.  Likewise, since the derivative of
a power of an expression can be easily expressed in terms of that
expression, no copying of @code{e1} is involved when @code{e3} is
constructed.  So, when @code{e3} is constructed it will print as
@code{3*(x+3*y)^2*cos((x+3*y)^3)} but the argument of @code{cos()} only
holds a reference to @code{e2} and the factor in front is just
@code{3*e1^2}.

As a user of GiNaC, you cannot see this mechanism of copy-on-write
semantics.  When you insert an expression into a second expression, the
result behaves exactly as if the contents of the first expression were
inserted.  But it may be useful to remember that this is not what
happens.  Knowing this will enable you to write much more efficient
code.  If you still have an uncertain feeling with copy-on-write
semantics, we recommend you have a look at the
@uref{http://www.cerfnet.com/~mpcline/c++-faq-lite/, C++-FAQ lite} by
Marshall Cline.  Chapter 16 covers this issue and presents an
implementation which is pretty close to the one in GiNaC.


@node Internal representation of products and sums, Package Tools, Expressions are reference counted, Internal Structures
@c    node-name, next, previous, up
@appendixsection Internal representation of products and sums

@cindex representation
@cindex @code{add}
@cindex @code{mul}
@cindex @code{power}
Although it should be completely transparent for the user of
GiNaC a short discussion of this topic helps to understand the sources
and also explain performance to a large degree.  Consider the 
unexpanded symbolic expression 
@tex
$2d^3 \left( 4a + 5b - 3 \right)$
@end tex
@ifnottex
@math{2*d^3*(4*a+5*b-3)}
@end ifnottex
which could naively be represented by a tree of linear containers for
addition and multiplication, one container for exponentiation with base
and exponent and some atomic leaves of symbols and numbers in this
fashion:

@image{repnaive}

@cindex pair-wise representation
However, doing so results in a rather deeply nested tree which will
quickly become inefficient to manipulate.  We can improve on this by
representing the sum as a sequence of terms, each one being a pair of a
purely numeric multiplicative coefficient and its rest.  In the same
spirit we can store the multiplication as a sequence of terms, each
having a numeric exponent and a possibly complicated base, the tree
becomes much more flat:

@image{reppair}

The number @code{3} above the symbol @code{d} shows that @code{mul}
objects are treated similarly where the coefficients are interpreted as
@emph{exponents} now.  Addition of sums of terms or multiplication of
products with numerical exponents can be coded to be very efficient with
such a pair-wise representation.  Internally, this handling is performed
by most CAS in this way.  It typically speeds up manipulations by an
order of magnitude.  The overall multiplicative factor @code{2} and the
additive term @code{-3} look somewhat out of place in this
representation, however, since they are still carrying a trivial
exponent and multiplicative factor @code{1} respectively.  Within GiNaC,
this is avoided by adding a field that carries an overall numeric
coefficient.  This results in the realistic picture of internal
representation for
@tex
$2d^3 \left( 4a + 5b - 3 \right)$:
@end tex
@ifnottex
@math{2*d^3*(4*a+5*b-3)}:
@end ifnottex

@image{repreal}

@cindex radical
This also allows for a better handling of numeric radicals, since
@code{sqrt(2)} can now be carried along calculations.  Now it should be
clear, why both classes @code{add} and @code{mul} are derived from the
same abstract class: the data representation is the same, only the
semantics differs.  In the class hierarchy, methods for polynomial
expansion and the like are reimplemented for @code{add} and @code{mul},
but the data structure is inherited from @code{expairseq}.


@node Package Tools, ginac-config, Internal representation of products and sums, Top
@c    node-name, next, previous, up
@appendix Package Tools

If you are creating a software package that uses the GiNaC library,
setting the correct command line options for the compiler and linker
can be difficult. GiNaC includes two tools to make this process easier.

@menu
* ginac-config::   A shell script to detect compiler and linker flags.
* AM_PATH_GINAC::  Macro for GNU automake.
@end menu


@node ginac-config, AM_PATH_GINAC, Package Tools, Package Tools
@c    node-name, next, previous, up
@section @command{ginac-config}
@cindex ginac-config

@command{ginac-config} is a shell script that you can use to determine
the compiler and linker command line options required to compile and
link a program with the GiNaC library.

@command{ginac-config} takes the following flags:

@table @samp
@item --version
Prints out the version of GiNaC installed.
@item --cppflags
Prints '-I' flags pointing to the installed header files.
@item --libs
Prints out the linker flags necessary to link a program against GiNaC.
@item --prefix[=@var{PREFIX}]
If @var{PREFIX} is specified, overrides the configured value of @env{$prefix}.
(And of exec-prefix, unless @code{--exec-prefix} is also specified)
Otherwise, prints out the configured value of @env{$prefix}.
@item --exec-prefix[=@var{PREFIX}]
If @var{PREFIX} is specified, overrides the configured value of @env{$exec_prefix}.
Otherwise, prints out the configured value of @env{$exec_prefix}.
@end table

Typically, @command{ginac-config} will be used within a configure
script, as described below. It, however, can also be used directly from
the command line using backquotes to compile a simple program. For
example:

@example
c++ -o simple `ginac-config --cppflags` simple.cpp `ginac-config --libs`
@end example

This command line might expand to (for example):

@example
cc -o simple -I/usr/local/include simple.cpp -L/usr/local/lib \
  -lginac -lcln -lstdc++
@end example

Not only is the form using @command{ginac-config} easier to type, it will
work on any system, no matter how GiNaC was configured.


@node AM_PATH_GINAC, Configure script options, ginac-config, Package Tools
@c    node-name, next, previous, up
@section @samp{AM_PATH_GINAC}
@cindex AM_PATH_GINAC

For packages configured using GNU automake, GiNaC also provides
a macro to automate the process of checking for GiNaC.

@example
AM_PATH_GINAC([@var{MINIMUM-VERSION}, [@var{ACTION-IF-FOUND} [, @var{ACTION-IF-NOT-FOUND}]]])
@end example

This macro:

@itemize @bullet

@item
Determines the location of GiNaC using @command{ginac-config}, which is
either found in the user's path, or from the environment variable
@env{GINACLIB_CONFIG}.

@item
Tests the installed libraries to make sure that their version
is later than @var{MINIMUM-VERSION}. (A default version will be used
if not specified)

@item
If the required version was found, sets the @env{GINACLIB_CPPFLAGS} variable
to the output of @command{ginac-config --cppflags} and the @env{GINACLIB_LIBS}
variable to the output of @command{ginac-config --libs}, and calls
@samp{AC_SUBST()} for these variables so they can be used in generated
makefiles, and then executes @var{ACTION-IF-FOUND}.

@item
If the required version was not found, sets @env{GINACLIB_CPPFLAGS} and
@env{GINACLIB_LIBS} to empty strings, and executes @var{ACTION-IF-NOT-FOUND}.

@end itemize

This macro is in file @file{ginac.m4} which is installed in
@file{$datadir/aclocal}. Note that if automake was installed with a
different @samp{--prefix} than GiNaC, you will either have to manually
move @file{ginac.m4} to automake's @file{$datadir/aclocal}, or give
aclocal the @samp{-I} option when running it.

@menu
* Configure script options::  Configuring a package that uses AM_PATH_GINAC.
* Example package::           Example of a package using AM_PATH_GINAC.
@end menu


@node Configure script options, Example package, AM_PATH_GINAC, AM_PATH_GINAC
@c    node-name, next, previous, up
@subsection Configuring a package that uses @samp{AM_PATH_GINAC}

Simply make sure that @command{ginac-config} is in your path, and run
the configure script.

Notes:

@itemize @bullet

@item
The directory where the GiNaC libraries are installed needs
to be found by your system's dynamic linker.
  
This is generally done by

@display
editing @file{/etc/ld.so.conf} and running @command{ldconfig}
@end display

or by
   
@display
setting the environment variable @env{LD_LIBRARY_PATH},
@end display

or, as a last resort, 
 
@display
giving a @samp{-R} or @samp{-rpath} flag (depending on your linker) when
running configure, for instance:

@example
LDFLAGS=-R/home/cbauer/lib ./configure
@end example
@end display

@item
You can also specify a @command{ginac-config} not in your path by
setting the @env{GINACLIB_CONFIG} environment variable to the
name of the executable

@item
If you move the GiNaC package from its installed location,
you will either need to modify @command{ginac-config} script
manually to point to the new location or rebuild GiNaC.

@end itemize

Advanced note:

@itemize @bullet
@item
configure flags
  
@example
--with-ginac-prefix=@var{PREFIX}
--with-ginac-exec-prefix=@var{PREFIX}
@end example

are provided to override the prefix and exec-prefix that were stored
in the @command{ginac-config} shell script by GiNaC's configure. You are
generally better off configuring GiNaC with the right path to begin with.
@end itemize


@node Example package, Bibliography, Configure script options, AM_PATH_GINAC
@c    node-name, next, previous, up
@subsection Example of a package using @samp{AM_PATH_GINAC}

The following shows how to build a simple package using automake
and the @samp{AM_PATH_GINAC} macro. The program used here is @file{simple.cpp}:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main(void)
@{
    symbol x("x");
    ex a = sin(x); 
    cout << "Derivative of " << a << " is " << a.diff(x) << endl;
    return 0;
@}
@end example

You should first read the introductory portions of the automake
Manual, if you are not already familiar with it.

Two files are needed, @file{configure.in}, which is used to build the
configure script:

@example
dnl Process this file with autoconf to produce a configure script.
AC_INIT(simple.cpp)
AM_INIT_AUTOMAKE(simple.cpp, 1.0.0)

AC_PROG_CXX
AC_PROG_INSTALL
AC_LANG_CPLUSPLUS

AM_PATH_GINAC(0.4.0, [
  LIBS="$LIBS $GINACLIB_LIBS"
  CPPFLAGS="$CFLAGS $GINACLIB_CPPFLAGS"  
], AC_MSG_ERROR([need to have GiNaC installed]))

AC_OUTPUT(Makefile)
@end example

The only command in this which is not standard for automake
is the @samp{AM_PATH_GINAC} macro.

That command does the following:

@display
If a GiNaC version greater than 0.4.0 is found, adds @env{$GINACLIB_LIBS} to 
@env{$LIBS} and @env{$GINACLIB_CPPFLAGS} to @env{$CPPFLAGS}. Otherwise, dies
with the error message `need to have GiNaC installed'
@end display

And the @file{Makefile.am}, which will be used to build the Makefile.

@example
## Process this file with automake to produce Makefile.in
bin_PROGRAMS = simple
simple_SOURCES = simple.cpp
@end example

This @file{Makefile.am}, says that we are building a single executable,
from a single sourcefile @file{simple.cpp}. Since every program
we are building uses GiNaC we simply added the GiNaC options
to @env{$LIBS} and @env{$CPPFLAGS}, but in other circumstances, we might
want to specify them on a per-program basis: for instance by
adding the lines:

@example
simple_LDADD = $(GINACLIB_LIBS)
INCLUDES = $(GINACLIB_CPPFLAGS)
@end example

to the @file{Makefile.am}.

To try this example out, create a new directory and add the three
files above to it.

Now execute the following commands:

@example
$ automake --add-missing
$ aclocal
$ autoconf
@end example

You now have a package that can be built in the normal fashion

@example
$ ./configure
$ make
$ make install
@end example


@node Bibliography, Concept Index, Example package, Top
@c    node-name, next, previous, up
@appendix Bibliography

@itemize @minus{}

@item
@cite{ISO/IEC 14882:1998: Programming Languages: C++}

@item
@cite{CLN: A Class Library for Numbers}, @email{haible@@ilog.fr, Bruno Haible}

@item
@cite{The C++ Programming Language}, Bjarne Stroustrup, 3rd Edition, ISBN 0-201-88954-4, Addison Wesley

@item
@cite{C++ FAQs}, Marshall Cline, ISBN 0-201-58958-3, 1995, Addison Wesley

@item
@cite{Algorithms for Computer Algebra}, Keith O. Geddes, Stephen R. Czapor,
and George Labahn, ISBN 0-7923-9259-0, 1992, Kluwer Academic Publishers, Norwell, Massachusetts

@item
@cite{Computer Algebra: Systems and Algorithms for Algebraic Computation},
J.H. Davenport, Y. Siret, and E. Tournier, ISBN 0-12-204230-1, 1988, 
Academic Press, London

@end itemize


@node Concept Index, , Bibliography, Top
@c    node-name, next, previous, up
@unnumbered Concept Index

@printindex cp

@bye

